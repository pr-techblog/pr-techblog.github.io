<!DOCTYPE html><html><head><title>از سیر تا پیاز ری‌اکت، نکست و ریداکس!</title><meta charset="utf-8" /><meta content='text/html; charset=utf-8' http-equiv='Content-Type'><meta http-equiv='X-UA-Compatible' content='IE=edge'><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'><meta property="og:locale" content="fa_IR" /><meta property="og:site_name" content="پول ریکوئست" /><meta name="twitter:image" content="/assets/images/pr.svg" /><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="theme-color" content="#000"><meta property="og:type" content="article" /><meta name="description" content="عمیق‌تر در مورد جاوااسکریپت، ری‌اکت و نکست‌جی‌اس بدونیم " /><meta property="og:description" content="عمیق‌تر در مورد جاوااسکریپت، ری‌اکت و نکست‌جی‌اس بدونیم " /><meta name="twitter:card" content="summary" /><meta name="twitter:description" content="عمیق‌تر در مورد جاوااسکریپت، ری‌اکت و نکست‌جی‌اس بدونیم " /><meta name="author" content="پول ریکوئست به قلم aien" /><meta property="og:title" content="از سیر تا پیاز ری‌اکت، نکست و ریداکس!" /><meta property="twitter:title" content="از سیر تا پیاز ری‌اکت، نکست و ریداکس!" /><link rel="stylesheet" type="text/css" href="/style.css" /><link rel="alternate" type="application/rss+xml" title="پول ریکوئست - پول ریکوئست، دست نوشته های فنی فارسی زبان" href="/feed.xml" /> <script src="/pr.js"></script><body><div class="site__container"><header class="site__header container"><figure class="site__header__brand"> <a href="http://pullrequest.ir"> <img src="/assets/images/pr.svg" alt="PR"> </a></figure><nav class="site__header__nav"><ul class="list--unstyled list--inline header__list text--center"><li> <a href="/about">پول ریکوئست چیست</a><li> <a href="/pr-authors">نویسندگان</a><li> <a href="/contribute">راهنمای انتشار مطالب در پول ریکوئست</a></ul></nav></header><hr class="site__header__divider container" /><main role="main" class="container"><article class="post post--single"><h1 class="post__title post__title--single">از سیر تا پیاز ری‌اکت، نکست و ریداکس!</h1><div class="post__info"> <span> <span class="lazyimage"> <img onload="window.pr.methods.addClass('img-loaded', this.parentNode)" onerror="window.pr.methods.addClass('img-error', this)" src="/assets/images/aien.jpg" alt="آیین سعیدی" class="img-rounded post__info__figure inline--middle" > </span> <span class="inline--middle post__author"><a href="http://pullrequest.ir/authors/aientech">آیین سعیدی</a></span> </span> <small><em>1397-03-01</em></small></div><div class="post__share text--left"><ul class="list--unstyled list--inline"><li><a class="button button--with-icon" target="_blank" href="https://twitter.com/intent/tweet?url=/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%B1%DB%8C-%D8%A7%DA%A9%D8%AA-%D9%86%DA%A9%D8%B3%D8%AA-%D8%AC%DB%8C-%D8%A7%D8%B3-%D9%88-%D8%B1%DB%8C%D8%AF%D8%A7%DA%A9%D8%B3/&via=http://pullrequest.ir&text=از سیر تا پیاز ری‌اکت، نکست و ریداکس!"> <i class="icon pricon-twitter"></i> توییتر </a><li><a class="button button--with-icon" target="_blank" href="https://telegram.me/share/url?url=http://pullrequest.ir/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%B1%DB%8C-%D8%A7%DA%A9%D8%AA-%D9%86%DA%A9%D8%B3%D8%AA-%D8%AC%DB%8C-%D8%A7%D8%B3-%D9%88-%D8%B1%DB%8C%D8%AF%D8%A7%DA%A9%D8%B3/"> <i class="icon pricon-telegram"></i> تلگرام </a></ul><nav class="post__tags post__tags--single"> <i class="icon pricon-tag"></i><ul class="list--unstyled list--inline"><li><a href="/tag/reactjs">#reactjs</a><li><a href="/tag/nextjs">#nextjs</a><li><a href="/tag/redux">#redux</a><li><a href="/tag/redux-thunk">#redux-thunk</a></ul></nav></div><div class="post__entry post__entry--single"><p>عمیق‌تر در مورد جاوااسکریپت، ری‌اکت و نکست‌جی‌اس بدونیم<h1 id="نکستجیاس-و-ریداکستانک-از-مبتدی-تا-پیشرفته">نکست‌جی‌اس و ریداکس‌تانک، از مبتدی تا پیشرفته</h1><p><img src="https://files.virgool.io/upload/users/3181/posts/uzcgpsjoceof/wbnq800rbiov.png" alt="" /><h1 id="مقدمه">مقدمه</h1><p>خیلی از دوستان من با موضوعات مختلفی خصوصا در زمینه جاوا‌اسکریپت دچار مشکل شدن. بعضی از مفاهیم رو نفهمیدن و یا نمیدونستن از کجا باید شروع کنن. برای همین تصمیم گرفتم که این مطلب رو بنویسم. قصد دارم اینجا برای سطوح مبتدی تا پیشرفته در مورد ری‌اکت و نکست‌جی‌اس و همچنین ریداکس توضیح بدم. و سعی میکنم این مطلب رو تا حد امکان گسترده کنم تا تمامی مواردی که برای یک برنامه‌نویس خوب شدن لازم هست رو پوشش بدم.<p>اما اساسا چرا این مطلب رو نوشتم؟ خب، اول از همه اینکه بتونم هر آنچه که بلد هستم رو یک‌جا نگه دارم و بعدا هم ازش استفاده کنم. دوم اینکه همچین آموزشی رو تقریبا هیچ‌کجای وب، و خصوصا تو سایت‌های ایرانی پیدا نکردم.<p>متنی که اینجا نوشته شده، حاصل چند سال تلاش من برای یادگیری، و تقریبا یک ماه برای خلاصه‌کردن تمام اون اطلاعات بود تا بتونم یک مرجع کامل رو بسازم، سعی کردم خط به خط کدها رو توضیح بدم و ریپازیتوری گیت رو باهاش سینک و همگام نگه‌دارم. از اینکه این مطالب به دست دیگران هم برسه و کمک به چند نفر بکنه واقعا خوشحال میشم، اما تنها خواهش من از خوانندگان و شما، اینه که اگر این مطلب رو جایی به اشتراک میذارید، منبع اون رو هم ذکر کنید.<p><a href="https://goo.gl/Fy2S8J">همچنین مطلب کامل رو در سایت خودم میتونید پیدا کنید و در مورد ری‌اکت و نکست‌جی‌اس بیشتر مطالعه کنید.</a><p>سپاس.<h1 id="جاوااسکریپت-و-اکمااسکریپت-ecmascript">جاوا‌اسکریپت و اکما‌اسکریپت (ECMAScript)</h1><p>اولین چیزی که لازم هست بدونید، اینه که جاوا‌اسکریپت توسط شرکت نِت‌اِسکیِپ (شرکت قدیمی موزیلا فایرفاکس) ساخته و به سازمان اِکما داده شد تا اون رو استانداردسازی کنن. اِکما سازمانیه که وظیفش استانداردسازی اطلاعاته.<p>اونچه که در نهایت از جاوا‌اسکریپت توسط سازمان اِکما ارائه شد، اِکما‌اِسکریپت بود. ساده‌تر بگم، اِکما‌اِسکریپت یک استاندارد هست، در حالی که جاوا‌اسکریپت محبوب‌ترین پیاده‌سازی از اون استاندارد به حساب میاد. جاوا‌اِسکریپت، اِکما‌اِسکریپت رو پیاده‌سازی میکنه و بر پایه اون ساخته میشه.<p>حالا سوالی که مطرح میشه، اینه که <strong>“ES” چیه</strong>؟<p>ای‌اِس، مخفف اِکما‌اِسکریپته (<strong>E</strong>CMA<strong>S</strong>cript)، هرجایی که ای‌اِس رو در کنار یک عدد دیدید، مثل ای‌اس۶، یادتون باشه که داره به یک نسخه از اِکما‌اِسکریپت یا در واقع یک نسخه از استاندارد اشاره میشه.<h1 id="ایاِس-es">ای‌اِس (ES)</h1><p>ای‌اِس تا به اینجا ۸ نسخه مختلف رو ارائه کرده، <strong>ای‌اِس۱، ۲، ۳ و ۴</strong> بین سال‌های ۱۹۹۷ تا ۱۹۹۹ ارائه شدن و دیگه ازشون پشتیبانی نمیشه. (ما هم کاری بهشون نداریم).<p><strong>ای‌اِس۵</strong> تقریبا ۱۰ سال بعد از اس‌اس۴ یعنی اواخر سال ۲۰۰۹ (تاریخ دقیق رو نمیدونم) ارائه داده شد.<p><strong>ای‌اِس۶</strong> در سال ۲۰۱۵ منتشر شد که برای راحتی کار، بهش ای‌اس۲۰۱۵ هم میگن. در واقع چون ای‌اس۶ در سال ۲۰۱۵ ارائه شده، بهش ای‌اِس۲۰۱۵ میگن!<p><strong>ای‌اِس۷/ای‌اس۲۰۱۶</strong> که مطمئنا میتونید پیشبینی کنید در سال ۲۰۱۶ منتشر شد.<p><strong>ای‌اس۸/ای‌اس۲۰۱۷</strong> هم، در سال ۲۰۱۷ منتشر شد.<h2 id="چرا-ورژنهای-مختلف-از-ایاس-منتشر-شدن">چرا ورژن‌های مختلف از ای‌اس منتشر شدن؟</h2><p>دلیلش اینه که هر وِرژِن، ویژگی‌های جدیدی رو ارائه کرده که با زمان خودش هم‌خوانی داشته باشه. فقط باید چند نکته رو به خاطر داشته‌باشید:<ol><li>پیشبینی میشه که هر سال یک نسخه جدید از اِکما‌اِسکریپت ارائه بشه،<li>اولین نسخه‌های اِکما‌اِسکریپت با عدد نسخه‌بندی میشدن، مثل ای‌اِس۱، ای‌اِس۲ و…<li>نسخه‌های جدید که از سال ۲۰۱۵ شروع شدن، به شکل <strong>ای‌اس[سال انتشار]</strong> نام‌گذاری میشن.<li>اکما یک استاندارده، جاوا‌اسکریپت محبوب‌ترین پیاده‌سازی از اون استاندارد هست.</ol><h2 id="چرا-ایاس۶">چرا ای‌اس۶؟</h2><p>نسخه ۶‌ام از اِکما‌اِسکریپت، ویژگی‌های خیلی خوبی رو به زبان جاوا‌اسکریپت اضافه کرد، و همین، یکی از دلایلی شد که ری‌اَکت به طور پیش‌فرض ازش پشتیبانی میکنه. مثلا مفاهیمی مثل «کلاس‌ها» و «ماژول‌ها»، که برای زبان‌های شئ‌گرا اجباری هستند، بهش اضافه شدن. از جمله ویژگی‌های دیگش، اضافه شدن دستورات <code class="highlighter-rouge">for</code>، جِنِراتور‌های شبیه به زبان پایتون، توابع فِلِشی (Arrow Function)، کالِکشِن‌ها، پرامِس‌ها (Promise) و غیره بوده.<p>متاسفانه هنوز مرورگرها پشتیبانی از ای‌اِس۶ رو کامل نکردن و ای‌اِس۶ به خودی خود تو مرورگرها پشتیبانی نمیشه. اینجاست که مفاهیم تِرَنس‌پایلِرها (transpiler) خودشون رو نشون میدن که بعد از توضیح توابع فِلِشی (برای راحتی کار میگم اَرو فانکشِن) بهشون میپردازم.<h2 id="arrow-functions">Arrow Functions</h2><p>یکی از ویژگی‌های خیلی خوبی که توی ای‌اِس۶ وجود داره، استفاده از اَرو فانکشن‌هاست. به اسمش دقت نکنید، مفهومش خیلی سادست. ارو فانکشن‌ها، در واقع همون توابع قدیمی جاوااسکریپت هستند (با ویژگی‌های جدید‌تر که اینجا بهشون کاری نداریم) که تو ای‌اس۶ به شکل دیگه‌ای تعریف میشن و موقع تِرَنس‌پایل (یکمی پایینتر توضیح میدم در این مورد) به شکل توابع جاوااسکریپت درمیان، مثلا:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span><span class="o">+</span><span class="nx">n</span>
<span class="p">}</span>

<span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div><p>بعد از تِرَنس‌پایل تبدیل میشن به:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">});</span>

<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">});</span>

<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">json</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div><h2 id="ترنسپایلر-transpiler">ترنس‌پایلر (transpiler)</h2><p>حتما تا به حال واژه‌های «کامپایلِر» و «مفسر» به گوشتون خورده. تِرَنس‌پایلِرها در واقع نوعی کامپایلر هستند با یک تفاوت اصلی:<p>کامپایلرها معمولا زبان رو به یک نسخه قابل اجرا برای ماشین تبدیل می‌کنن، مثلا زبان سی، کدهای باینری یا همون صفر و یک میسازه، یا جاوا بایت‌کد رو تولید میکنه.<p>این درحالیه که ترنس‌پایلرها، یک سورس‌کد رو به یک سورس‌کد دیگه تبدیل می‌کنن (یا مثلا به یک زبان دیگه که مستقیم برای ماشین قابل درک نیست و باید دوباره کامپایل، اینتِرپرِت یا همون تفسیر بشه). مثلا کافی‌اسکریپت (CoffeeScript) که از خودش جاوا‌اسکریپت تولید میکنه، یا <strong>بابِل (Babel) که ای‌اس۶ رو به ای‌اس۵ (قابل پشتیبانی برای مرورگرها) تبدیل می‌کنه.</strong><p>بابِل یا بِیبِل (Babel) یک ترنس‌پایلر برای ای‌اس۶ هست که اون رو به ای‌اس۵ تبدیل میکنه. ای‌اس۵ توسط مرورگرها خیلی خوب پشتیبانی میشه و در حقیقت، ای‌اس۵ همون جاوا‌اسکریپتیه که عموما باهاش آشنایی دارن.<h2 id="بابِل-بِیبِل-babel">بابِل، بِیبِل…؟ (Babel)</h2><p>بابل یک تِرَنس‌پایلِر برای جاوا‌اسکریپته. بابل رو اکثرا بخاطر توانایی خوبش تو تبدیل ای‌اس۶ به ای‌اس۵ میشناسن.<p>به عنوان مثال این کد که با ای‌اس۶ نوشته شده:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">input</span> <span class="o">=</span> <span class="err">\</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="err">\</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// \[2, 3, 4\]</span>
</code></pre></div></div><p>توسط بابل تبدیل میشه به کد ای‌اس۵:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="err">\</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="err">\</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}));</span> <span class="c1">// \[2, 3, 4\]</span>
</code></pre></div></div><p>که تقریبا همه‌جا قابل اجراست. بابل خیلی خوب از <a href="https://www.saidi27.com/glossary/polyfill-(%D9%BE%D9%84%DB%8C%E2%80%8C%D9%81%DB%8C%D9%84)">پُلی‌فیل‌های</a> جاوا‌اسکریپت پشتیبانی میکنه و باعث میشه که کد جاوا‌اسکریپت ساخته شده برای مرورگرهای قدیمی هم قابل پشتیبانی باشه. به همین خاطر، بابل باعث میشه شما از تمام ویژگی‌های ای‌اس۶ استفاده کنید بدون اینکه پشتیبانی از نسخه‌های قدیمی مرورگرها رو از دست بدید (مفهوم پُلی‌فیل اینجا معلوم میشه).<h1 id="فرانتاند-و-مفاهیم-اِسپیاِی-spa">فرانت‌اند و مفاهیم اِس‌پی‌اِی (SPA)</h1><p>اطلاعاتی که ما در اینترنت میبینیم، مجموعه‌ای از کدهای HTML، JavaScript و CSS هستن. قدیم‌ها، زمانی که خیلی از برنامه‌نویس‌ها از PHP (هنوز هم استفاده میکنن) برای نوشتن صفحات وب استفاده می‌کردن و جِی‌اِس مثل امروز محبوب نبود، هر صفحه از سایت باید بصورت جداگانه نوشته می‌شد. و زمانی که کاربر روی یک لینک کلیک میکرد، کل صفحه از اول رِندِر (Render) می‌شد. این فرایند برای کاربر، خسته‌کننده و طاقت‌فرسا بود و حتی گاهی بخاطر زمان زیادی که باید برای بارگذاری صفحه صرف میکرد، از ادامه کارش پشیمون میشد.<p>کم‌کم تکنیک‌هایی مثل اِی‌جَکس (AJAX) استفاده شدن، که مثلا وقتی صفحه در حال بارگذاری بود، شروع میکرد یک نماد کوچک لودینگ و بارگذاری (بهش معمولا میگن اِسپینِر یا spinner) رو نشون دادن و کاربر رو متوجه میکرد که اطلاعات در حال ارسال و دریافتن.<p>این ایده، که اطلاعات تو یک صفحه بارگذاری بشن و کاربر مدام مجبور به عوض کردن صفحه‌ها نشه (مگر در مواقع لازم) باعث ایجاد تعریف جدیدی از وب‌اَپلیکِیشِن‌ها شد، اِس‌پی‌اِی (SPA) یا Single Page Application راهش رو به لغت‌نامه‌ی برنامه‌نویس‌ها باز کرد!<p>SPA هدفش ایجاد یک تجربه کاربری بهتر برای کاربرهاست. در حقیقت، SPA کار رو برای برنامه‌نویس سخت‌تر و برای کاربر راحتتر کرد. تو یک اپلیکیشن SPA ایده‌آل، کاربر شما متوجه عوض شدن صفحه‌ها نمیشه و احساس میکنه که همه‌چیز در حال رخ‌دادن تو یک صفحست.<p>اما داستان سمت برنامه‌نویس کمی فرق می‌کنه. کاربر زمانی میتونه اطلاعات رو تو مرورگرش ببینه، که کد‌های HTML ساخته شده باشن، و این یعنی برنامه‌نویس باید با هر درخواست کاربر، یا کلا صفحه رو از اول بارگذاری کنه (که دیگه SPA نیست) یا اینکه اون قسمتی از سایت رو که مرتبط با کاربر هست یا نیاز به تغییر داره رو مجددا با داده‌های جدید که از سمت سرور اومدن بارگذاری کنه.<p>اینجاست که سایت شما، تا حدود زیادی از سمت سرور خودش جدا میشه و مفهوم جدیدی به عنوان <strong>فرانت‌اِند (Front End)</strong> رو تعریف می‌کنه. فرانت‌اند و بَک‌اِند، در زمان‌های دور وجود نداشتن یا خیلی به هم نزدیک بودن. شما یک سایت رو کامل می‌نوشتید و مثلا تو یک صفحه PHP، همزمان از HTML و JavaScript استفاده می‌کردید. هر زمان که کاربر درخواست صفحه‌ی جدیدی رو میداد، شما یک اسکریپت جدید رو بارگذاری و صفحه‌های مربوطه رو از نو بازنویسی می‌کردید.<p>زمانی که تعاریف فرانت‌اند و بَک‌اند ایجاد شدند، طراحی سایت شکل جدیدی به خودش گرفت. فرانت‌اند یجورایی بیشتر نماد <strong>طراحی سایت</strong> شد و بَک‌اند بیشتر نماد <strong>منطق کاری (Business Logic)</strong>. کدها سمت بک‌اند نوشته می‌شن و اطلاعات رو موقع نیاز به فرانت‌اند ارسال می‌کنن. از اینجا به بعد، برنامه‌نویس فرانت نیازی نداره که نگران SQL و دستورات مربوط به ارتباط با پایگاه داده و دریافت محصولات از اون باشه، یا حتی نگران فرایند عضویت و ورود به سایت. فرانت‌اند خودش رو بیشتر با بهبود تجربه کاربری درگیر کرد. لازم هست که بگم، این یک مفهوم کلی و جداسازی کلی بک‌اند و فرانت‌اند هست. اینکه وظیفه‌ی برنامه‌نویس چی باشه، نسبت به هر پروژه قابل تغییر هست و امرو، خیلی از برنامه‌نویس‌ها به هرد شاخه بَک و فرانت تسلط دارن.<p>اینجا بود که مارس ۲۰۱۳، فیسبوک اولین نسخه از کتاب‌خونه ری‌اَکت رو ارائه داد…<h1 id="ریاکت-react">ری‌اکت (React)</h1><p>ری‌اَکت یا ری‌اَکت‌جِی‌اِس، یک کتابخونست برای ساختن روابط کاربری. ری‌اکت به برنامه‌نویس این اجازه رو میده، که بتونه وب‌اپلیکیشن‌های بزرگی رو بسازه که از اطلاعات مختلفی استفاده می‌کنن و میتونن تو یک صفحه تغییر کنن، بدون اینکه صفحه رو مجدد لود کنن (مفهوم SPA). هدف اصلی سازندگان ری‌اکت، سرعت، سادگی و مقیاس‌پذیری بوده.<p>ری‌اکت صرفا تلاش میکنه تا رابط کاربری رو از راه Virtual-DOM تغییر بده. اینکه این ساز.کار به چه صورتی هست رو فعلا تشریح نمیکنم اما، اگر با معماری MVC آشنا باشید، ری‌اکت اون قسمت “V” رو به خودش اختصاص میده و میتونه با بقیه کتابخونه‌های جی‌اس خودش رو وفق بده.<p>یکی دیگه از اَشکال ری‌اکت، ری‌اَکت‌نِیتیو هست که کمک میکنه، نرم‌افزارهای (اکثرا موبایل) نِیتیو یا سازگار با سیستم‌عامل توسط ری‌اکت ساخته بشن. ضمنا ری‌اکت از جی‌اس‌اکس (JSX) برای نمایش و ساخت المان‌ها استفاده میکنه که توضیح میدم در این مورد.<h2 id="جیاساکس-jsx">جی‌اس‌اکس (JSX)</h2><p>جِی‌اِس‌اِکس، یک زبان مشابه با HTML یا XML که کمک میکنه، تیکه‌های سایت (Component) جدای از هم ساخته بشن و به شکل یک شئ جاوا‌اسکریپت در بیان.<p>ساده‌تر بگم، با JSX میشه ساختارهای مشابه به HTML رو ساخت. مثال:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nav</span> <span class="o">=</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span> <span class="nx">id</span><span class="o">=</span><span class="s2">"nav"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">"#"</span><span class="o">&gt;</span><span class="nx">Home</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="nx">li</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">"#"</span><span class="o">&gt;</span><span class="nx">About</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="nx">li</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">"#"</span><span class="o">&gt;</span><span class="nx">Clients</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="nx">li</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">"#"</span><span class="o">&gt;</span><span class="nx">Contact</span> <span class="nx">Us</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="nx">li</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div><p>اینجا، <code class="highlighter-rouge">nav</code> به عنوان یک کامپونِنت (Component) شناخته میشه. و شما میتونید جاهای مختلف برنامه، ازش استفاده کنید (یکبار بنویسید و چندبار استفاده کنید).<p>این استفاده از JSX یکی دیگه از ویژگی‌های ری‌اکت به حساب میاد! اینکه شما برنامتون رو به <strong>تیکه‌های کوچکتری تقسیم می‌کنید و میتونید در جاهای مختلفی ازش استفاده کنید.</strong><h2 id="کمی-بیشتر-در-مورد-ریاکت">کمی بیشتر در مورد ری‌اکت</h2><p>دنیای ری‌اکت جالبه. فرض کنید که یک کامپوننت رو ساختیم، مثلا یه لیست از محصولات. بعد کاربر روی یکی از محصولات کلیک میکنه، صفحه محصول باز میشه و کاربر محصول رو میبینه. کاری که ری‌اکت انجام داده چیه؟ ری‌اکت متوجه میشه که کدوم قسمت‌های سایت باید تغییر کنن و فقط اونها رو تغییر میده! پس اول شناسایی میکنه که چه چیزی تغییر کرده، و بعد تغییرات رو اعمال میکنه. ری‌اکت، به جای اینکه کل صفحه رو از اول بازسازی کنه، فقط قسمت‌هایی که تغییر کردند یا به نوعی وضعیتشون تغییر کرده رو با داده‌های جدید پر می‌کنه و اونها رو از نو میسازه و خیلی هم سریع این کار رو انجام میده!<h2 id="نصب-و-شروع-کار-با-ریاکت">نصب و شروع کار با ری‌اکت</h2><p>تصمیم ندارم اینجا به طور عمیق وارد ری‌اکت بشم و کد منبع ری‌اکت رو تشریح کنم، هدفم اینه که فضای کلی برای ورود به نکست‌جی‌اس رو ایجاد و شما رو با ساختار کلی و نحوه کار با ری‌اکت آشنا کنم. پس پیش میریم برای نصب ری‌اکت‌جی‌اس و یک آشنایی کلی با این کتابخونه.<h3 id="نصاب-ریاکت">نصاب ری‌اکت</h3><p>نصاب ری‌اکت، که توسط فیسبوک ساخته شده، تو مخازن npm موجوده و میتونید اون رو به صورت عمومی توی سیستم‌عاملتو بریزید:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install</span> <span class="nt">-g</span> create-react-app

<span class="se">\#</span> ساخت نرم‌افزار
<span class="nv">$ </span>create-react-app my-app-name

<span class="se">\#</span> نصب وابسته‌ها <span class="o">(</span>Dependencies<span class="o">)</span>
<span class="nv">$ </span><span class="nb">cd </span>my-app-name
<span class="nv">$ </span>npm <span class="nb">install</span>
</code></pre></div></div><p>مطمئن باشید که حتما <a href="https://www.npmjs.com/get-npm"><code class="highlighter-rouge">npm</code> رو روی کامپیوترتون نصب کردید</a>. یکی از مهم‌ترین ویژگی‌های <code class="highlighter-rouge">create-react-app</code> اینه که تمام ابزارهای لازم رو از قبل برای شما فراهم کرده. مثلا از قبل Babel برای شما نصب شده و نیازی نیست که خودتون رو درگیر نصب و راه‌اندازیش بکنید. حالا میریم سراغ یک توضیح در مورد ساختار این کتابخونه.<h3 id="ساختار-پوشهها">ساختار پوشه‌ها</h3><p>اگر داخل پوشه <code class="highlighter-rouge">public</code> رو ببینید، متوجه حضور فایل <code class="highlighter-rouge">index.html</code> میشید. این فایل در حقیقت نقطه شروع برنامست و حتما باید وجود داشته باشه، این یکی از بایدهای برنامه‌های ساخته شده با <code class="highlighter-rouge">create-react-app</code> هست. یه نگاهی به داخل این فایل میندازیم:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1, shrink-to-fit=no"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"theme-color"</span> <span class="na">content=</span><span class="s">"#000000"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!--
      manifest.json provides metadata used when your web app is added to the
      homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
    --&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"manifest"</span> <span class="na">href=</span><span class="s">"%PUBLIC_URL%/manifest.json"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"shortcut icon"</span> <span class="na">href=</span><span class="s">"%PUBLIC_URL%/favicon.ico"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the \`public\` folder during the build.
      Only files inside the \`public\` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running \`npm run build\`.
    --&gt;</span>
    <span class="nt">&lt;title&gt;</span>React App<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;noscript&gt;</span>
      You need to enable JavaScript to run this app.
    <span class="nt">&lt;/noscript&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"root"</span><span class="nt">&gt;&lt;/div&gt;</span>
    <span class="c">&lt;!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the &lt;body&gt; tag.

      To begin the development, run \`npm start\` or \`yarn start\`.
      To create a production bundle, use \`npm run build\` or \`yarn build\`.
    --&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div><p>همینطور که میبینید، این فایل چیز خاصی رو داخل خودش نداره. به جز خط ۲۸ام. که اِلِمانی تعریف شده با آی‌دی <code class="highlighter-rouge">root</code>، این رو تا اینجا توی ذهنتون داشته باشید. اتفاقی که از اینجا به بعد رخ میده، توی فایل <code class="highlighter-rouge">src/index.js</code> قرار داره. بذارید یه نگاهی هم به این فایل بندازیم:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s1">'react'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">ReactDOM</span> <span class="k">from</span> <span class="s1">'react-dom'</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">'./index.css'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="s1">'./App'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">registerServiceWorker</span> <span class="k">from</span> <span class="s1">'./registerServiceWorker'</span><span class="p">;</span>

<span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">App</span> <span class="o">/&gt;</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'root'</span><span class="p">));</span>
<span class="nx">registerServiceWorker</span><span class="p">();</span>
</code></pre></div></div><p>این فایل هم یکی از فایل‌هایی هست که حتما باید وجود داشته باشه. دلیلش اینه که تو تتظیمات <code class="highlighter-rouge">create-react-app</code> این دو فایل به عنوان نقاط شروع برنامه تعریف شدند. خود <code class="highlighter-rouge">create-react-app</code> این دو فایل رو به هم متصل میکنه و زمانی رو که شما لازم هست خودتون بذارید تا تنظیمات رو انجام بدید، براتون ذخیره می‌کنه. میریم سراغ بررسی این فایل:<ol><li>اول از همه، این کد با استاندارد ای‌اس۶ نوشته شده. اگر قرار بود از استاندارد ای‌اس۵ (یا به اصطلاح Common JS) پیروی کنیم، باید مینوشتیم: <code class="highlighter-rouge">var React = require("react");</code> تا کلاس ری‌اکت رو به پروژه اضافه کنیم. بعدا به این خواهیم پرداخت که این خط چه کارهایی انجام میده. فعلا بریم سراغ خط بعد.<li>تو خط دوم، شئیی به نام <code class="highlighter-rouge">ReactDOM</code> فراخوانی شده. برای اطلاعاتون، قبل از نسخه ۰.۱۴ ری‌اکت، کتابخونه‌های <code class="highlighter-rouge">react</code> و <code class="highlighter-rouge">react-dom</code> یکی بودن. تنها وظیفه‌ای که ReactDOM به عهده داره، اینه که با اِی‌پی‌آی‌های <code class="highlighter-rouge">render</code> یا <code class="highlighter-rouge">ReactDOM.render</code> یک اِلِمان جِی‌اِس‌اِکس رو، داخل یک اِلِمان دیگه (اینجا <code class="highlighter-rouge">document.getElementById('root')</code>) نمایش بده.<li>خط سوم، خیلی ساده اِستایل‌های موجود در فایل <code class="highlighter-rouge">index.css</code> رو، برای تمام اِلِمان‌هایی که اینجا قرار هست رِندِر بشن، اعمال میکنه.<li>خط چهارم یک کامپوننت رو، اینجا به اسم <code class="highlighter-rouge">app</code>، از <strong>یک کلاس ری‌اکت</strong> فراخوانی کرد و بعد تو خط هفتم، به ReactDOM گفت که این کامپوننت رو داخل اِلِمان root رِندِر کنه. اما بریم سراغ <strong>کلاس ری‌اکت</strong> و ببینیم اصلا حرفش چی هست.</ol><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'react'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">logo</span> <span class="k">from</span> <span class="s1">'./logo.svg'</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">'./App.css'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">header</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-header"</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">logo</span><span class="p">}</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-logo"</span> <span class="nx">alt</span><span class="o">=</span><span class="s2">"logo"</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-title"</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">React</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/header</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">p</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-intro"</span><span class="o">&gt;</span>
          <span class="nx">To</span> <span class="kd">get</span> <span class="nx">started</span><span class="p">,</span> <span class="nx">edit</span> <span class="o">&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">src</span><span class="o">/</span><span class="nx">App</span><span class="p">.</span><span class="nx">js</span><span class="o">&lt;</span><span class="sr">/code&gt; and save to reload</span><span class="err">.
</span>        <span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</code></pre></div></div><p>خب، طبق معمول خط اول، کلاس‌های ری‌اکت (<code class="highlighter-rouge">React</code>) و کامپوننت (<code class="highlighter-rouge">Component</code>) رو از کتابخونه ری‌اکت فراخوانی کرده. اما تفاوت براکت‌ها <code class="highlighter-rouge">{}</code> برای کامپوننت و ری‌اکت که براکت نداره چیه؟ این یکی از ویژگی‌های ای‌اس۶ هست که به این صورته:<p>فرض کنید کلاسی رو به شکل زیر تعریف کردیم:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">YeClassJadid1</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">YeClassJadid2</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">YeClassJadid3</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">YeClassJadid4</span> <span class="kd">extends</span> <span class="nx">YeClassDige</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span>
</code></pre></div></div><p>اشیائی که تعریف شدن همشون ویژگی کلاس بودن رو دارن، اما تفاوتشون به این صورته که، کلاس اول (<code class="highlighter-rouge">YeClassJadid1</code>)، فقط تو همون فایلی که تعریف شده، یا اسکوپی (Scope) که تعریف شده قابل خونده شدنه و جاهای دیگه قابل استفاده نیست. کلاس دوم (<code class="highlighter-rouge">YeClassJadid2</code>) رو شما میتونید جاهای دیگه، با استفاده از روش <code class="highlighter-rouge">import { YeClassJadid2 } from "path/to/the/file"</code> فراخوانی کنید. دلیلش هم اینه که کلاس دوم، به طور پیش‌فرض کلاس اصلی این ماژول یا فایل نیست. اما، کلاس سوم <code class="highlighter-rouge">YeClassJadid3</code> به طور پیش‌فرض، کلاس اصلی تعریف شده (<code class="highlighter-rouge">default</code>) و زمانی که بخواد فراخوانی بشه، میتونه به صورت <code class="highlighter-rouge">import YeClassJadid3 from "path/to/the/file"</code> یا حتی <code class="highlighter-rouge">import YeEsmeDige from "path/to/the/file"</code> فراخوانی بشه. و در نهایت هم، کلاس چهارم <code class="highlighter-rouge">YeClassJadid4</code> مثل کلاس‌های قبلی، اما با ارث‌بری از کلاس <code class="highlighter-rouge">YeClassDige</code> خارج یا اِکسپورت میشه.<p>نکته‌ای که گفتنش حائز اهمیته، اینه که هر ماژول، یا هر فایل، فقط یک کلاس رو میتونه به صورت <code class="highlighter-rouge">default</code> خارج کنه! تو مثال بالا، یکی از کلاس‌های <code class="highlighter-rouge">YeClassJadid3</code> یا <code class="highlighter-rouge">YeClassJadid4</code> میتونن خاصیت <code class="highlighter-rouge">default</code> رو داشته باشن!<p>باز هم میگم، هدفم این نیست که عمیق وارد ری‌اکت بشم و فقط میخوام شما رو با این محیط آشنا کنم. برنامه اینه که شما وارد نِکست‌جِی‌اِس بشید و من اونجا بیشتر درمورد خود ری‌اکت می‌نویسم. تا اینجا هم خوب پیش اومدیم، بریم سراغ کامپوننت‌ها و یه کامپوننت بسازیم.<h3 id="ساخت-کامپوننت">ساخت کامپوننت</h3><p>برای اینکه بهتر متوجه بشید کامپوننت‌ها چی هستند، صفحات وب رو به تیکه‌های کوچیک تقسیم کنید. مثلا نوار بالای صفحه یه کامپوننت جدا، لیست محصولات یه کامپوننت جدا و همینطور ادامه بدید…<p>📷<p>اول، کل صفحه یک کامپوننت هست، بعد هر تیکه‌ای از صفحه تقسیم به کامپوننت‌های کوچک‌تر میشه و پیش میره. این موضوع رو با ساخت یک کامپوننت راحتت درک میکنید. برای شروع، داخل پوشه <code class="highlighter-rouge">src</code> یک پوشه دیگه به اسم <code class="highlighter-rouge">components</code> یا هر اسم دیگه‌ای که دوست دارید ایجاد کنید. اینکه پوشه‌ها چطور باشن، دست خودتونه، اما یادتون باشه که یک‌سری استاندارد یا کانوِنشِن (Convention) برای اینکار هست که مدیریت کد رو راحتتر میکنه. در نهایت داخل این پوشه، یک فایل به اسم <code class="highlighter-rouge">MyComponent.js</code> بسازید و داخلش این کد رو قرار بدید:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s2">"react"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">ThisIsAComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">1</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">2</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">3</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">4</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">5</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>کامپوننتی که ساختیم خیلی سادست، یه لیست با ۵تا آیتم. که باید، حتما داخل تابع <code class="highlighter-rouge">render</code> قرار بگیرن، و این تابع هم، فقط باید یک اِلِمان رو، یا چند اِلِمانی که داخل یک المان والد جمع شدند رو برگردونه. حالا باید این کامپوننت رو داخل <code class="highlighter-rouge">App.js</code> فراخوانی کنیم. کار خیلی ساده‌ایه. <code class="highlighter-rouge">App.js</code> رو باز کنید و اون رو به شکل زیر تغییر بدید:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'react'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">logo</span> <span class="k">from</span> <span class="s1">'./logo.svg'</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">'./App.css'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">ThisIsAComponent</span> <span class="k">from</span> <span class="s2">"./components/MyComponent"</span>

<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">header</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-header"</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">logo</span><span class="p">}</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-logo"</span> <span class="nx">alt</span><span class="o">=</span><span class="s2">"logo"</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-title"</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">React</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/header</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">p</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"App-intro"</span><span class="o">&gt;</span>
          <span class="nx">To</span> <span class="kd">get</span> <span class="nx">started</span><span class="p">,</span> <span class="nx">edit</span> <span class="o">&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">src</span><span class="o">/</span><span class="nx">App</span><span class="p">.</span><span class="nx">js</span><span class="o">&lt;</span><span class="sr">/code&gt; and save to reload</span><span class="err">.
</span>        <span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>        
        <span class="o">&lt;</span><span class="nx">ThisIsAComponent</span><span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</code></pre></div></div><p>خب، کامپوننت رو ساختیم و اون رو به کامپوننت اصلی اضافه کردیم. حالا دستور <code class="highlighter-rouge">npm start</code> رو اجرا کنید و بعد داخل مرورگر به آدرس <a href="http://localhost:3000/">localhost:3000</a> برید و نتیجه رو ببینید. بعد از اینکه تموم شد، میتونید سرور رو ببندید و برید سراغ مرحله بعد.<h3 id="گریزی-به-state">گریزی به state</h3><p>فرض کنید که قرار بود دکمه‌ای وجود داشته باشه، تا با کلیک کردن روش، کامپوننت ما یا حتی یک بخشی از کامپوننت نمایش داده بشه و یا مخفی بشه، یکی از این دو حالت ساده! اینجا لازم هست که کمی در مورد مفهوم استِیت (state) توضیح بدم. کامپوننت‌های شما، همینطور که تا اینجا دیدید، کار خاصی رو به خودی خودشون انجام نمیدن، چون در حقیقت اِلِمانهای HTML هستند، یا حتی شاید لازم باشه در طول زمان تغییراتی رو پیدا کنن. ملموس‌ترین نوع تغییر، زمانی رخ میده که شما اطلاعاتی رو از جایی (از یک سرور) دریافت میکنید و می‌خواید به کاربر نشون بدید، اما تو مدت زمانی که اطلاعات در حال دریافت هستند، علاقه دارید تا یک اسپینر (spinner) رو نمایش بدید، تا به کاربر بگید که اطلاعات در حال بارگزاری هستن. یه سناریوی دیگه اینکه، با کلیک روی یک چِک‌باکس (checkbox) یک فیلد مخفی شده رو نمایش بدید و مثال‌های دیگه. اینجاست که استیت به کمک شما میاد.<p>استیت در حقیقت محل ذخیره‌ي آخرین تغییرات و حالات کامپوننته. مثلا شما بهش میگید که کامپوننت من در حالت عادی، نمایش داده میشه، اما من میخوام، زمانی که کاربر روی یک دکمه کلیک میکنه، کامپوننتم رو مخفی کنم. اینجا، نمایش داده شدن یا مخفی شدن، جز حالات یا استیت کامپوننت به حساب میاد. <strong>ری‌اکت، زمانی که استیت تغییر میکنه، کامپوننت رو مجدد بارگزاری یا رِندِر میکنه</strong>.<p>برای اینکه با استیت هم کار کنیم و بهتر درکش کنیم، به تریتیب زیر، به کامپوننت <code class="highlighter-rouge">ThisIsAComponent</code> استیت میدیم،<ol><li>حالت دیفالت یا اولیه رو برای کامپوننت تعریف میکنیم<li>توسط یک ایونت (Event) حالت یا همون استیت رو تغییر میدیم.</ol><p>کامپوننت رو به شکل زیر بازنویسی میکنیم:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s2">"react"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">ThisIsAComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">()</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">isHidden</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">toggleState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
            <span class="na">isHidden</span><span class="p">:</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isHidden</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">toggleState</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Change</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">ul</span> <span class="nx">hidden</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isHidden</span><span class="p">}</span><span class="o">&gt;</span>
                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">1</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">2</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">3</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">4</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">5</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>کارهایی که انجام شده، به همراه توضیحاتشون به ترتیب زیر هستن:<ol><li><code class="highlighter-rouge">constructor</code> به کامپوننت اضافه شده. این تابع که در حقیقت از <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">تعاریف کلاس در جاوا‌اسکریپت</a> برگرفته شده، کارهای متفاوتی رو میتونه انجام بده. اما یادتون باشه، <strong>هر موقع که میدونستید کامپوننتتون قرار هست حالات مختلفی رو برای نمایش داشته باشه، حالت اولیش (Initial State) رو اینجا تعریف کنید.</strong> مهمترین نکته اینه که به محض تعریف کردن <code class="highlighter-rouge">constructor</code>، تابع <code class="highlighter-rouge">super()</code> فراخوانی بشه. اگر فراموش کنید که <code class="highlighter-rouge">super()</code> رو بلافاصله فراخوانی کنید، <code class="highlighter-rouge">this</code> که در حقیقت همون کامپوننت شماست و اطلاعات کامپوننت رو توی خودش داره، خالی خواهد موند و در نتیجه امکان استفاده از اِستِیت و بقیه ویژگی کامپوننت‌ها رو نخواهید داشت.<li>قدم بعدی، داخل <code class="highlighter-rouge">construct</code> و زیر <code class="highlighter-rouge">super()</code>، استیت اولیه یا همون Default رو تعریف کردم. شکل تعریفش هم یه شئ ساده بوده که داخلش فقط از <code class="highlighter-rouge">isHidden: false</code> استفاده کردم تا بگم، در حالت عادی نمایش داده نمیشه (اینکه چطور و چه چیزی از این حالت استفاده میکنه و تغییر میکنه رو پایین‌تر توضیح میدم)<li>یک تابعی رو تعریف کردم با اسم دلخواه <code class="highlighter-rouge">toggleState</code> که قرار هست موقع کلیک کردن دکمه، فراخوانی بشه. کاری هم که انجام میده، خیلی ساده، استیت رو تغییر میده. کد نوشته شده شاید شما رو یکم سردرگم کنه. تعریف کد به این شکله: <code class="highlighter-rouge">isHidden: !this.state.isHidden</code> و یعنی، مقدار جدید <code class="highlighter-rouge">isHidden</code> برابر خواهد بود با هر آنچه که <code class="highlighter-rouge">this.state.isHidden</code> بوده، اما چون یک <code class="highlighter-rouge">!</code> هم اولش آوردم، یعنی اون مقدار رو بر عکسش کن. پس اگر <code class="highlighter-rouge">this.state.isHidden</code> برابر با <code class="highlighter-rouge">false</code> بود، مقدار جدیدش برابر با <code class="highlighter-rouge">true</code> میشه و برعکس.<li>چون یک دکمه هم به کامپوننت اضافه کردم، باید کل اِلِمان‌ها رو داخل یک اِلِمان اصلی و والد جا بدم. برای همین هم، تمام المان‌ها رو داخل یک <code class="highlighter-rouge">div</code> گذاشتم.<li>زمانی که کاربر روی دکمه کلیک میکنه، رویداد (Event) <code class="highlighter-rouge">onClick</code> اتفاق میوفته. اینجا بهش گفتم، زمانی که این رویداد اتفاق افتاد، تابع <code class="highlighter-rouge">toggleState</code> رو صدا بزنه. ضمنا از <code class="highlighter-rouge">bind</code> هم استفاده کردم، چون دکمه‌ها در حالت عادی، رویدادها رو انجام نمیدن و بایند (Bind) موظف هست تا حالت اصلی شئی که بهش پاس داده میشه رو حفظ و برای تابع مربوطه ارسالش کنه. در این مورد بعدا بیشتر توضیح میدم.<li>و در نهایت، به المان <code class="highlighter-rouge">ul</code> گفتم، تا مخفی بودن یا نبودنش رو از <code class="highlighter-rouge">this.state.isHidden</code> بگیره. حالا، هر موقع که <code class="highlighter-rouge">isHidden</code> تغییر کنه، المان <code class="highlighter-rouge">ul</code> مجددا رِندِر میشه.</ol><p>برنامه رو تست کنید و ببینید که کارکردش چطوره. کارتون که تموم شد، میریم تا یکم دیگه با تئوری دست و پنجه نرم کنیم.<h2 id="درک-مفاهیم-ریاکت">درک مفاهیم ری‌اکت</h2><p>مهم‌ترین تفاوت کتاب‌خونه ری‌اکت با فرِیم‌وُرک‌هایی مثل انگولار، اینه که ری‌اکت فقط برای فرانت‌اند ساخته شده. در مورد ری‌اکت، چیزهای خیلی زیادی برای گفتن وجود داره. اما دوتا از ویژگی‌های اصلی ری‌اکت، داشتن مفاهیمی مثل Properties یا به طور خلاصه Prop و همچنین State هست که قبل‌تر کمی با مفهوم State آشنا شدیم. اینجا تصمیم دارم در مورد این دو و همچنین چرخه زندگی کامپوننت‌ها بیشتر توضیح بدم.<h3 id="props">Props</h3><p>پراپ‌ها در واقع راهی برای ارتباط بین کامپوننت‌ها و جز ویژگی‌های اونها هستند (هرجا که شما کلاس <code class="highlighter-rouge">React.Component</code> رو استفاده یا همون <code class="highlighter-rouge">extend</code> کنید، میتونید ازشون بهره‌ ببرید). مهم‌ترین ویژگی پراپ‌ها، اینه که از سمت کامپوننت والد به فرزند منتقل میشن و اصطلاحا uni-directional (یک‌طرفه) هستن. زمانی هم وجود داره که شما مثل استِیت، پراپ‌های اولیه رو تعریف میکنید تا کامپوننت شما با اطلاعات اولیه (و نه حالات اولیه)، شروع به کار کنه. پراپ‌ها به شما کمک میکنن تا اطلاعات رو بین کامپوننت‌ها جابجا کنید، و زمانی که کاربر بخواد مستقیما روی خود کامپوننت تغییری اعمال کنه، باید از استیت استفاده بشه. بذارید با یک مثال ساده از پراپ استفاده کنیم:<p>فرض کنید که توی کامپوننت <code class="highlighter-rouge">ThisIsAComponent</code> از یک تگ هدر <code class="highlighter-rouge">h1</code> استفاده میکردیم و قرار بود مقدار داخلش رو توسط کامپوننت والد تغییر بدیم. کد جدیدمون به این شکل میشد (فقط تابع رِندِر رو گذاشتم و مابقی کد دست‌نخورده باقی مونده):<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">toggleState</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Change</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">ul</span> <span class="nx">hidden</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isHidden</span><span class="p">}</span><span class="o">&gt;</span>
                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">1</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">2</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">3</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">4</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="nx">Item</span> <span class="mi">5</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>        <span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div><p>حالا باید مقداری رو برای <code class="highlighter-rouge">title</code> از کامپوننت والد، یعنی <code class="highlighter-rouge">App</code> در نظر بگیرم. کار آسونیه و به شکل زیر تغییری رو تو <code class="highlighter-rouge">App.js</code> ایجاد میکنم:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="o">&lt;</span><span class="nx">ThisIsAComponent</span> <span class="nx">title</span><span class="o">=</span><span class="p">{</span><span class="s2">"This is a new title"</span><span class="p">}</span><span class="sr">/</span><span class="err">&gt;
</span><span class="p">...</span>
</code></pre></div></div><h3 id="state">State</h3><p>پراپ‌ها نباید تغییر کنن (به اصطلاح باید Immutable باشن)، برای همین از استیت استفاده میشه. در حالت عادی، کامپوننت‌ها استیت ندارن و از این جهت اصطلاحا بهشون Stateless گفته میشه. کامپوننت‌هایی که استیت پیدا میکنن، بهشون Stateful میگن.<p>کاربرد استیت برای اینه که کامپوننت بتونه اطلاعاتی که در هر بازسازی دریافت میکنه رو حفظ کنه. زمانی که شما از <code class="highlighter-rouge">this.setState()</code> استفاده میکنید، وضعیت کامپوننت بروزرسانی و مجددا بازسازی میشه. تمام این فرایند بازسازی توسط ری‌اکت اتفاق می‌افته و خیلی هم سریعه.<p>پراپ و استیت خیلی شبیه به هم هستند و تقریبا کار مشابهی رو انجام میدن، اما برای کارهای متفاوتی ازشون استفاده میشه. این امکام وجود داره تا خیلی از کامپوننت‌های شما Stateless باشن.<h3 id="چرخه-زندگی-کامپوننتها-component-lifecycle">چرخه زندگی کامپوننت‌ها (Component Lifecycle)</h3><p>کامپوننت‌ها به شما کمک میکنن تا یو‌آی (UI) رو به تیکه‌های کوچکتر تقسیم کنید. در حالت کلی، شما کامپوننت‌ها رو به شکل کلاس‌های جاوااسکریپت تعریف میکنید:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Greeting</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>اما کامپوننت‌ها صرفا جهت نمایش ساخته نمیشن و کارهای بیشتری میشه باهاشون انجام داد. اصطلاحا هر کامپوننتی برای خودش یک چرخه‌زندگی بخصوص یا Lifecycle داره که چندتا از پر کاربردترین‌ها رو توضیح میدم:<ul><li><code class="highlighter-rouge">constructor()</code> که دقیقا قبل از بارگذاری کامپوننت توسط ری‌اکت خونده میشه. بهترین استفادش، تعریف <code class="highlighter-rouge">state</code> اولیه کامپوننت هست. اگر کامپوننت stateless باشه، نیازی به تعریف این تابع نیست.<li><code class="highlighter-rouge">componentWillMount()</code> دقیقا قبل از بارگذاری خونده میشه. و قبل از تابع <code class="highlighter-rouge">render()</code> اتفاق میوفته. به همین خاطر تعریف استیت تو این تابع پیشنهاد نمیشه. این تابع سمت سرور کارهاش رو انجام میده و اصطلاحا server-side هست. (در این مورد تو بخش <a href="https://virgool.io/d/uzcgpsjoceof/edit#universal-isomorphic-apps">Isomorphism</a> توضیح میدم)<li><code class="highlighter-rouge">componentDidMount()</code> بعد از اینکه کامپوننت بارگذاری شد، خونده میشه. این تابع بهترین جا برای ارسال درخواست‌ها به سرور شماست و اگر استیت رو تو این تابع با استفاده از تابع <code class="highlighter-rouge">this.setState()</code> تغییر بدید، باعث میشید که باز دوباره تابع <code class="highlighter-rouge">render()</code> فراخوانی بشه<li><code class="highlighter-rouge">componentWillReceiveProps(nextProps)</code> زمانی فراخوانی میشه، که شما از طریق کامپوننت والد، پراپ‌های کامپوننت فرزند رو تغییر بدید و بخواید استیت جدید رو بر اساس پراپ‌های جدید تنظیم کنید. برای اینکار میتونید آرگومان‌های <code class="highlighter-rouge">nextProps</code> و <code class="highlighter-rouge">this.props</code> رو با هم مقایسه کرده و تغییرات رو ایجاد کنید. (مقایسه رو حتما انجام بدید!)<li><code class="highlighter-rouge">componentWillUpdate(nextProps, nextState)</code> قبل از بارگذاری مجدد رخ میده، اگر پراپ‌ها و استیت‌های کامپوننت تغییری کرده باشن.<li><code class="highlighter-rouge">componentDidUpdate(prevProps, prevState)</code> بلافاصله بعد از بارگذاری مجدد اتفاق میوفته و به شما این امکان رو میده تا المان‌ها رو دستکاری کنید.<li><code class="highlighter-rouge">componentDidCatch(error, info)</code> برای مدیریت اِرورها و خطاها تو UI استفاده میشه.<li><a href="https://reactjs.org/docs/react-component.html">مطالعه بیشتر…</a></ul><h3 id="جمعبندی">جمع‌بندی</h3><p>پراپها استفاده میشن تا اطلاعات از کامپوننت والد به کامپوننت فرزند یا حتی داخل کامپوننت فرزند منتقل بشن. پراپ‌ها تغییرناپذیر یا به اصطلاح Immutable هستند و نباید در هر رندر تغییر کنند.<p>استیت برای این استفاده میشه تا اطلاعات رو تغییر بدیم، یا اطلاعات تغییر یافته رو نمایش بدیم و اصطلاحا تغییر پذیر یا Mutable هستند. مثلا کاربر چیزی رو در سایت سرچ میکنه و بلافاصله زیرش تعدادی از نزدیک‌ترین نتایج جست‌وجو نمایش داده میشه.<h1 id="مفهوم-isomorphic-یا-universal">مفهوم Isomorphic یا Universal</h1><p>زمانهای قدیم، قبل از موقعی که NodeJS بین برنامه‌نویس‌ها محبوب بشه، جاوااسکریپت زبانی بود که باهاش تغییراتی رو تو صفحه‌های وب ایجاد میکردن تا صفحه‌ها از حالت مرده و استاتیک خارج بشن. تا اون موقع زبان جاوااسکریپت، زبانی بود که تو مرورگر کاربر اجرا میشد و به اصطلاح Client Side یا سمت کاربر بود. بعد از ظهور NodeJS جاوااسکریپت این قابلیت رو پیدا کرد که تو محیط سمت سرور هم اجرا بشه و بعد از اون جاوااسکریپت به یک زبان Server Side هم تبدیل شد.<p>ایزومورفیزم (Isomorphism) از ریاضیات گرفته شده و «هم‌سان» معنی میشه. چون واژه ایزومورفیک برای برنامه‌نویس‌ها کمی مشکل‌ساز میتونه باشه، به جاش از واژه یونیورسال (Universal) هم استفاده میکنن.<p>ایزوموفیک در شاخه وب، به معنی ساخته شدن صفحه سمت سرور یا سمت کاربر هست و در حالت کلی به NodeJS و خود JavaScript اشاره میکنه. برای اینکه تعریف رو ساده‌تر کنم، اینطور در نظر بگیرید که، کدی که سمت سرور ساخته شده، به صورت HTML به کاربر ارسال میشه و کاربر میتونه تو کد صفحهش اون رو ببینه. اما کدی که سمت کاربر ساخته میشه، تو کدهای صفحه قابل مشاهده نیست. اینجا لازم هست که به این نکته اشاره کنم، که منظور از سرور، الزاما بک‌اند نیست، و اونچه که مد نظر هست، ابزاریه که وظیفه تبادل ارتباطات رو به عهده داره.<p>دلایل مختلفی وجود دارن که برنامه‌نویس‌ها به اپ‌های ایزومورف علاقه‌مندند:<ul><li>بهبود سئو،<li>پرفورمنس بهتر،<li>و نگهداری راحت‌تر.</ul><p>یکی از مضوعاتی که خیلی در این مورد مهم هست، اینه که کد‌های ایزومورفیک که سمت کاربر ساخته شدن، توسط موتورهای جست‌وجو به خوبی خونده نمیشن، برای همین هم اپ‌های SPA معمولا با این ساختار دچار مشکل میشن و لازم هست تا کدشون سمت سرور ساخته بشه. (سرور رو الزاما با کامپیوتر سرور اشتباه نگیرید!)<h1 id="promise-و-درک-ناهمگامسازی-asynchronous">Promise و درک ناهم‌گام‌سازی (Asynchronous)</h1><p>بیاید با هم یه دنیای جالبی رو تجسم کنیم، تو این دنیای ما، هنوز گوگل وجود نداره و شما رئیس یک شرکت «پاسخ به سوالات» هستید. نحوه کار به این شکله که کاربر سوال خودش رو بسته‌بندی میکنه (Data Package) و اون رو به یک پست‌چی میده، پست‌چی این بسته رو میاره برای شرکت شما (Request) و شما بسته رو باز میکنید، به سوال جواب میدید و اون رو به پست‌چی میدید و ایشون هم برای کاربر جواب رو میبره (Response). پروسه تا اینجا واضحه فقط چند شرط وجود داره:<p>از اونجایی که شرکت ما خیلی خاصه :دی،<ol><li>کاربر زمانی که بسته رو به پست‌چی میده، باید دم در خونه صبر کنه تا پست‌چی برگرده (و از کار و زندگیش هم می‌افته)<li>پستچی تا زمانی که شما پاسخ رو بسته‌بندی نکردید و بهش تحویل ندادید پیش شما میمونه.</ol><p>این روش ارتباط، روش هم‌گام یا اصطلاحا Synchronous نام داره و همون روش قدیمیه کار با اینترنته، کد PHP مینوشتیم و با هربار کلیک رو دکمه، کاربر باید منتظر صفحه جدید میموند و نمیتونست کارهای دیگه توی سایت رو انجام بده.<p>حالا شرکتمون رو کمی پیشرفته‌تر میکنیم، فرایند همون شکل قبلی رو داره اما:<ol><li>زمانی که کاربر درخواستش رو بسته‌بندی کرد و به پست‌چی داد، برمی‌گرده خونش و کارهاش رو انجام میده<li>شما فقط یک پست‌چی ندارید و پست‌چی‌ها میتونن از کاربر درخواست‌های مختلفی رو بگیرن و برای شما بیارن</ol><p>این نوع ارتباط، ارتباط نا‌هم‌گام یا Asynchronous نام داره و خیلی تو وب‌اپ‌های SPA پر کاربرده و AJAX یکی از معروف‌ترین تکنیک‌ها برای برقراری این نوع ارتباطهاست. تو نسخه‌های جدید جی‌اس، برای اینکه کاربر رو منتظر نذاریم بعد از اینکه درخواستش رو ارسال کرد، <strong>بهش قول میدیم که در آینده جوابی رو برای درخواستش ارسال میکنیم</strong>، و کاربر میتونه به کارش ادامه بده و ماهم پردازشمون رو انجام میدیم. اینجاست که پرامِس (پرامیس؟) یا همون Promiseها خودشون رو نشون میدن.<p>قبل از معرفی شدن پرامس‌ها، تو جاوااسکریپت از Callbackها استفاده میشد، کال‌بک‌ها توابعی بودن که مثلا به عنوان آرگومان یک تابع دیگه تعریف میشدن، تا هنگام بُروز یک رویداد خاص (Event) کار خاصی رو هم انجام بدن. مشکل اینجا بود که ایده‌ی کال‌بک‌ها، هرچقدر هم که قشنگ بوده، تو پردازش‌های پیچیده مدیریت کد رو خیلی سخت میکرده و به اصطلاح، برنامه‌نویس رو وارد جهنم کالبَک‌ها یا همون Callback-Hell میکرده. برای همین پرامس‌ها ساخته شدند تا جایگزینی برای کال‌بک‌ها باشن.<p>پرامس‌ها یا جوابی رو برمیگردونن یا اینکه دلیلی رو برای عدم انجام موفقیت‌آمیز اون فرایند ارائه میدن. از اینجا میشه گفت که پرامس‌ها ساختار مشابهی مثل <code class="highlighter-rouge">try/catch</code> دارن و از همه مهمتر، سه وضعیت کلی رو شامل میشن:<ol><li><strong>Pending</strong>: که یعنی در حال انجام کاری هستند،<li><strong>fulfilled</strong>: که یعنی کارشون رو به خوبی انجام دادن و<li><strong>rejected</strong>: که یعنی از پس کاری که بهشون داده شده بر نیومدن.</ol><p>یه مثال ساده برای اینکه با نمونه‌ای از یک پرامس آشنا بشید به این شکله:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">process</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">save</span><span class="p">)</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">handleErrors</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div><p>اینجا، تابع <code class="highlighter-rouge">process</code> صبر میکنه تا کار تابع <code class="highlighter-rouge">fetch</code> تموم بشه، بعد تابع <code class="highlighter-rouge">save</code> منتظر <code class="highlighter-rouge">process</code> میمونه و اگر هرکدوم از این توابع جایی به مشکل خوردند، تابه <code class="highlighter-rouge">handleErrors</code> وظیفش رو انجام میده.<p>اگر هرکدوم از این توابع، پرامس باشن، میتونن ساختار مشابهی رو برای خودشون بگیرن، در واقع این قابلیت رو به شما میدن تا بتونید پرامس‌ها رو تودرتو کنید.<h2 id="استفاده-از-fetch">استفاده از fetch</h2><p>حالا که متوجه مفهوم ایزومورفیک و همچنین درخواست‌های نا‌همگام شدید، بریم تا با یه مثال تو پروژمون به درک بیشتری ازشون برسیم.<p>قدم اول، نصب کتابخونه <code class="highlighter-rouge">isomorphic-fetch</code> از مخازن npm هست. <code class="highlighter-rouge">fetch</code> یکی از کتابخونه‌های مورد علاقه‌ی من که در کنارش کتابخونه <code class="highlighter-rouge">axios</code> وجود داره. تفاوت عمده این دو کتابخونه، تو پردازش اطلاعات هست و اکسیوس برای ای‌اس۶ آمادگی بیشتری داره، منتهی من طبق عادت پیش میرم و از فِچ (fetch) استفاده میکنم.<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install</span> <span class="nt">--save</span> isomorphic-fetch
</code></pre></div></div><p>کتابخونه رو نصب کنید، اینکه واژه ایزومورفیک اولش استفاده شده، نشون میده که این کتابخونه رو، هم میشه سمت سرور و هم سمت کاربر استفاده کرد. حالا، کامپوننت <code class="highlighter-rouge">ThisIsAComponent</code> رو یکمی تغییر میدیم. در نهایت کدمون باید به شکل زیر بشه:<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s2">"react"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">fetch</span> <span class="k">from</span> <span class="s2">"isomorphic-fetch"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">ThisIsAComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">()</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">done</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="na">items</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="err">\</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">fetchData</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
            <span class="na">done</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">});</span>

        <span class="nx">fetch</span><span class="p">(</span><span class="s1">'http://jsonplaceholder.typicode.com/posts'</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">data</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
                    <span class="na">done</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
                    <span class="na">items</span><span class="p">:</span> <span class="nx">res</span>
                <span class="p">})</span>
            <span class="p">})</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fetchData</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Get</span> <span class="nx">Data</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">p</span> <span class="nx">hidden</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">done</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>                <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
                    <span class="p">{</span>
                        <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
                            <span class="k">return</span> <span class="p">(</span>
                                <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>                            <span class="p">)</span>
                        <span class="p">})</span>
                    <span class="p">}</span>
                <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>خط به خط بریم جلو ببینیم چه اتفاقی افتاده:<ol><li>اول، از کتابخونه <code class="highlighter-rouge">isomorphic-fetch</code> شئ <code class="highlighter-rouge">fetch</code> رو فراخوانی کردم.<li>تو تابع constructor، استیت اولیه رو تغییر دادم و به جای <code class="highlighter-rouge">isHidden</code> که اول داشتیم، <code class="highlighter-rouge">done</code> رو، که وظیفه نگهداری از وضعیت بارگذاری آیتم‌ها رو به عهده داره و <code class="highlighter-rouge">items</code> که نگهدارنده آیتم‌های دریافت شده از سرور هستند رو ساختم.<li>تابع <code class="highlighter-rouge">toggleState</code> رو پاک کردم و به جاش از <code class="highlighter-rouge">fetchData</code> استفاده کردم. اسمش رو هم خودم انتخاب کردم. داخل این تابع اتفاقات جالبی میوفته.<br /> زمانی که این تابع خونده میشه (یا در واقع رو دکمه‌ای کلیک میشه که باید این تابع رو اجرا کنه) وضعیت <code class="highlighter-rouge">done</code> به <code class="highlighter-rouge">false</code> تغییر پیدا میکنه. چون در حقیقت آیتمی دریافت و کار ما هم تموم نشده.<br /> قدم بعدی، از <code class="highlighter-rouge">fetch</code> استفاده کردم تا از یک آدرس پیش‌فرض، یک‌سری اطلاعات الکی رو دریافت کنم. نکته مهم اینه که <code class="highlighter-rouge">fetch</code> یک پرامس هست و وضعیتش رو میشه کنترل کرد. برای همین، تو خط پایینش گفتم، هر موقع که دریافت اطلاعات تموم شد، از اطلاعات دریافت شده که اسمشون رو <code class="highlighter-rouge">data</code> گذاشتم استفاده کن و…<li>یکی از مهم‌ترین تفاوت‌های <code class="highlighter-rouge">fetch</code> و <code class="highlighter-rouge">axios</code> تو این مرحلست، پاسخی که <code class="highlighter-rouge">fetch</code> به شما برمیگردونه، یک پاسخ خام هست و باید تبدیل به دیتای قابل خوندن بشه. <code class="highlighter-rouge">fetch</code> این کار رو با برگردوندن یک پرامس انجام میده (برای نوشتن توابع از <a href="https://virgool.io/d/uzcgpsjoceof/edit#arrow-functions">Arrow Functionها</a> استفاده کردم). پس گفتم، زمانی که جواب رو از سرور گرفتی، اون رو به <code class="highlighter-rouge">json</code> تبدیل کن (که خود تابع <code class="highlighter-rouge">json</code> یک پرامس برمیگردونه) و بعد از اینکه عمل تبدیل به <code class="highlighter-rouge">json</code> درست انجام شد، از حاصلش استفاده کن تا دوباره استیت رو تغییر بدی.<br /> <code class="highlighter-rouge">done</code> رو هم برابر با <code class="highlighter-rouge">true</code> کردم تا نشون بدم عمل دریافت اطلاعات کامل شده. در نهایت نتیجه حاصل از دریافت اطلاعات، یا همون آیتم‌های مورد نظرم رو، که حالا تبدیل به <code class="highlighter-rouge">json</code> شدند، داخل <code class="highlighter-rouge">items</code> استیت ذخیره کردم.<br /> اینکار باعث میشه که ری‌اکت، یکبار دیگه کامپوننت‌هایی که از این استیت استفاده میکنن رو بارگذاری کنه. در نهایت هم بررسی میکنه که آیا اشکالی وجود داشته تو کل این فرایند یا نه.<li>آخر سر، تو تابع <code class="highlighter-rouge">render</code> دکمه Get Data رو به تابع <code class="highlighter-rouge">fetchData</code> وصل کردم. یک تگ <code class="highlighter-rouge">p</code> هم اضافه کردم که بهش گفتم، وضعیت <code class="highlighter-rouge">hidden</code> بودنش رو از <code class="highlighter-rouge">done</code> موجود تو استیت بگیره. (هر موقع که بارگذاری تموم شده بود، این المان محو میشه و هرموقع بارگذاری در حال انجام بود، این المان نمایش داده میشه)<li>داخل المان <code class="highlighter-rouge">div</code> که به جای <code class="highlighter-rouge">ul</code> نشسته، با استفاده از تابع <code class="highlighter-rouge">map()</code> که شکل جدیدی از <code class="highlighter-rouge">forEach</code> هست، آیتم‌ها رو نمایش دادم. (پایین‌تر درمورد <code class="highlighter-rouge">map</code> توضیحات بیشتری میدم)</ol><p><a href="https://goo.gl/Fy2S8J">ادامه مطلب در سایت خودم…</a></div><div class="post__share text--center"><ul class="list--unstyled list--inline"><li><a class="button button--with-icon" target="_blank" href="https://twitter.com/intent/tweet?url=/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%B1%DB%8C-%D8%A7%DA%A9%D8%AA-%D9%86%DA%A9%D8%B3%D8%AA-%D8%AC%DB%8C-%D8%A7%D8%B3-%D9%88-%D8%B1%DB%8C%D8%AF%D8%A7%DA%A9%D8%B3/&via=http://pullrequest.ir&text=از سیر تا پیاز ری‌اکت، نکست و ریداکس!"> <i class="icon pricon-twitter"></i> توییتر </a><li><a class="button button--with-icon" target="_blank" href="https://telegram.me/share/url?url=http://pullrequest.ir/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%B1%DB%8C-%D8%A7%DA%A9%D8%AA-%D9%86%DA%A9%D8%B3%D8%AA-%D8%AC%DB%8C-%D8%A7%D8%B3-%D9%88-%D8%B1%DB%8C%D8%AF%D8%A7%DA%A9%D8%B3/"> <i class="icon pricon-telegram"></i> تلگرام </a></ul></div><script> window.pr.methods.docReady(function() { var singleEntry = window.pr.methods.selectElementByClassName('.post__entry--single'); var excerptEntry = window.pr.methods.selectElementByClassName('.post__excerpt'); if (singleEntry) window.pr.methods.parseTextForEmojis(singleEntry); else if (excerptEntry) window.pr.methods.parseTextForEmojis(excerptEntry); }) </script><hr /><div class="comments"><div id="disqus_thread"></div><script async defer src='https://pwl-rykhwyst.disqus.com/embed.js' onerror="disqusHandler();"></script> <script type="text/javascript"> var disqusHandler = (function (w) { var methods = w.pr.methods; /* methods.docReady(function () { loadDisqusScript() }); function loadDisqusScript() { methods.getAjax('https://pwl-rykhwyst.disqus.com/embed.js', null, function (e) { addDisqusErrorIfNotPresent(); // Parse any emoji inside error methods.parseTextForEmojis(document.getElementById('comment__error')); }) } */ function addDisqusErrorIfNotPresent() { var comments = methods.selectElementByClassName('.comments'); /* Add only for the 1st time */ if (!methods.selectElementById('comment__error')) { /* Add error to .comments */ comments.appendChild(createDisqusError()); /* Parse any emoji inside error */ methods.parseTextForEmojis(document.getElementById('comment__error')); } } function createDisqusError() { var err = document.createElement('div'); err.id = 'comment__error'; window.pr.methods.addClass('alert', err); err.innerHTML = 'اگر این پیام رو میبینین، به این معنیه که اسکریپت Disqus براتون لود نشده. سرویس Disqus توی ایران فیلتر شده!! <strong>لطفا وی پی ان تون رو روشن کنین و صفحه فعلی رو ریفرش کنین.</strong> :پی'; return err; } return addDisqusErrorIfNotPresent; })(window); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></article></div><footer class="site__footer clearfix"><div class="site__footer__brand" onclick="window.pr.methods.goToTop()"> <img class="img-block" src="/assets/images/pr.svg" alt="PR"></div><div class="container clearfix"><nav class="pull-right site__footer__menu"><ul class="list--unstyled list--inline site__footer__list"><li> <a target="_blank" href="https://github.com/pr-techblog"> <i class="icon pricon-github"></i> گیتهاب </a><li> <a target="_blank" href="https://twitter.com/pr_techblog"> <i class="icon pricon-twitter"></i> توییتر </a></ul></nav><div class="pull-left text--ltr site__footer__copyright">Made with ❦ @ <strong>PullRequest</strong></div></div></footer></div><script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-93910742-1', 'auto'); ga('send', 'pageview', { 'page': '/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%B1%DB%8C-%D8%A7%DA%A9%D8%AA-%D9%86%DA%A9%D8%B3%D8%AA-%D8%AC%DB%8C-%D8%A7%D8%B3-%D9%88-%D8%B1%DB%8C%D8%AF%D8%A7%DA%A9%D8%B3/', 'title': 'از سیر تا پیاز ری‌اکت، نکست و ریداکس!' }); </script>
